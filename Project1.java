/*
 * This is the driver class for the 8-Puzzle solver.
 */

import java.util.PriorityQueue;
import java.util.Comparator;
import java.util.Random;
import java.util.HashMap;
import java.util.Scanner;

public class Project1
{
    static final int SIZE = 3;
    static final int STEP_COST = 1;
    
    static int numberOfNodes = 0;
    static int maxDepth = 0;
 
    //This is what represents the goal state.
    static char[][] goal = {{'0', '1', '2'}, {'3', '4', '5'}, {'6', '7', '8'}};
    //static char[][] goal = {{'1', '2', '3'}, {'4', '5', '6'}, {'7', '8', '0'}};
      
    //The frontier used in the A* Search sorts nodes by g(n) + h(n).
    static PriorityQueue<Node> frontier = new PriorityQueue<>();
    
    //A hash map is used to store already explored states so that checking
    //if a state has already been generated is very quick.
    static HashMap explored = new HashMap();
    
    public static void main(String[] args)
    {
        Scanner kb = new Scanner(System.in);        
        while(true) {
            System.out.print("**8-Puzzle Solver**\n" +
                             "(1) Solve a puzzle provided by user\n" +
                             "(2) Solve a puzzle generated by program\n" +
                             "(3) Display A* Search analytics\n" +
                             "(4) Quit\n==> Select option (1-4): ");
            String choice = kb.nextLine();
            switch(choice) {
                case "1":
                    calculateSinglePuzzle(true);
                    break;
                case "2":
                    calculateSinglePuzzle(false);
                    break;
                case "3":
                    System.out.print("Enter the lowest depth to be shown in " +
                                     "the results: ");
                    int lowDepth = kb.nextInt();
                    System.out.print("Enter the highest depth to be shown in " +
                                     "the results: ");
                    int highDepth = kb.nextInt();  
                    System.out.print("Enter the number of puzzles to be solved"+
                                     " (per depth level, per heuristic): ");
                    int iterations = kb.nextInt();
                    System.out.println();
                    displayResults(lowDepth, highDepth, iterations);
                    System.out.println("\nPress <Enter> to continue.");
                    kb.nextLine();
                    kb.nextLine();
                    break;
                case "4":
                    System.exit(0);
                    break;              
            }
        }
    }
    
    /**
     * This method generates a single puzzle, either generated by the user
     * (if userInput is true), or generated by the program (if userInput is
     * false). After solving the puzzle using A* Search and using both
     * heuristic equations, the method displays the number of steps taken to
     * solve the puzzle, along with the number of nodes, max depth, and time
     * taken to solve for both heuristics.
     * @param userInput If true, prompts the user to input a puzzle; if false,
     *                  randomly generates a puzzle.
     */
    public static void calculateSinglePuzzle(boolean userInput) {
        char[][] puzzle;
        Scanner kb = new Scanner(System.in);
        if(userInput)
            puzzle = getPuzzleFromUser();
        else {
            do {
                puzzle = generateRandomPuzzle();
            } while(!solvable(puzzle));
        }
        if(puzzle != null) {
            int numberOfNodesH1, numberOfNodesH2, maxDepthH1, maxDepthH2;
            long timeH1, timeH2, start, end;
            start = System.currentTimeMillis();
            Node solution = aStarSearch(puzzle, true);
            end = System.currentTimeMillis();
            timeH1 = end-start;
            numberOfNodesH1 = numberOfNodes;
            maxDepthH1 = maxDepth;

            start = System.currentTimeMillis();
            solution = aStarSearch(puzzle, false);
            end = System.currentTimeMillis();
            timeH2 = end-start;
            numberOfNodesH2 = numberOfNodes;
            maxDepthH2 = maxDepth;

            Comparator<Node> depthComparator = new NodeDepthComparator();
            PriorityQueue<Node> result = new PriorityQueue<>(10, 
                                                             depthComparator);
            while(solution != null) {
               result.add(solution);
               solution = solution.parent();
            }
            result.remove();
            if(!userInput) {
                System.out.print("Generated puzzle: ");
                printArray(puzzle, false);
                System.out.println();
            }
            System.out.println("Number of steps: " + result.size());
            System.out.println("Solution steps (directions to move the blank " +
                               "tile):");
            while(!result.isEmpty())
                System.out.print(result.remove().getAction() + 
                                 (result.isEmpty() ? "\n" : ", "));                                               
            System.out.println("Number of nodes (H1 heuristic): " + 
                               numberOfNodesH1);
            System.out.println("Number of nodes (H2 heuristic): " + 
                               numberOfNodesH2);
            System.out.println("Max depth (H1 heuristic): " + maxDepthH1);
            System.out.println("Max depth (H2 heuristic): " + maxDepthH2);
            System.out.println("Time elapsed in ms (H1 heuristic): " + timeH1);
            System.out.println("Time elapsed in ms (H2 heuristic): " + timeH2);
        }
        System.out.print("\nPress <Enter> to continue.");
        kb.nextLine();
    }
    
    /**
     * This method prompts the user to input a string of SIZE*SIZE numbers (0-9)
     * and generates a puzzle based on that input.
     * @return A puzzle (double char array) that represents what the user 
     *         inputted.
     */
    public static char[][] getPuzzleFromUser() {
        char[][] puzzle;
        Scanner kb = new Scanner(System.in);
        System.out.println("Enter a puzzle in a linear format");
        System.out.println("Example:");
        printArray(goal, true);
        System.out.println(" = ");
        printArray(goal, false);
        System.out.print("\n ==> Enter puzzle: ");
        String puzzleString = kb.nextLine();
        if(validPuzzleString(puzzleString)) {
            puzzle = stringToPuzzle(puzzleString);
            if(solvable(puzzle))
                return puzzle;
            else {
                System.out.print("The puzzle you entered is not solvable.");
                return null;
            }
        }
        else {
           System.out.println("Invalid input.");
           return null;
        }
    }
    
    /**
     * This method runs A* Search n number of times and displays analytics of the
     * search. For each depth, the method runs (iterations*2) times ("iteration"
     * times using the h1 heuristic and "iteration" times using the h2
     * heuristic), disregarding any results that do not produce a max depth of
     * the current depth that the method is on.
     * 
     * The method uses randomly generated puzzles to solve, and each puzzle that
     * is either unsolvable or has an invalid depth that the method is currently
     * on is put in a hash table so that an identical puzzle that is generated
     * afterward is not attempted until the next set of A* Searches is 
     * performed.
     * 
     * Each successful test case creates a TestCase object, which stores the
     * successful node (returned by the A* Search), the number of nodes that 
     * were created until the result was found, the depth of that node, the
     * particular heuristic that was used to find that result, and the
     * amount of time taken (in milliseconds) to solve that puzzle.
     * 
     * After all the test cases are created, they are displayed. The method
     * displays the depth, the average number of nodes generated for solutions
     * of that depth (for both heuristics separately), and the average time
     * taken to find solutions of that depth.
     * @param depthLow The lowest depth that is used to display results.
     * @param depthHigh The highest depth that is used to display results.
     * @param iterations The number of iterations, per depth level, per
     *                   heuristic.
     */
    public static void displayResults(int depthLow, int depthHigh, 
                                      int iterations) {
        char[][] puzzle;
        PriorityQueue<TestCase> testCases = new PriorityQueue();
        HashMap createdPuzzles = new HashMap();
        for(int i = depthLow; i <= depthHigh; i++) {
            createdPuzzles.clear();
            int depthCounter = 0;
            while(depthCounter < iterations) {             
                puzzle = ( i > 20 ? generateRandomPuzzle() : scramblePuzzle(i));
                if(!createdPuzzles.containsKey(puzzleToInt(puzzle))) {
                    createdPuzzles.put(puzzleToInt(puzzle), puzzle);
                    if(solvable(puzzle)) {
                        long start = System.currentTimeMillis();
                        Node testCase = aStarSearch(puzzle, true);
                        long end = System.currentTimeMillis();
                        if(testCase != null && testCase.getDepth() == i) {
                            testCases.add(new TestCase(testCase, numberOfNodes, 
                                                       testCase.getDepth(), 
                                                       true, end-start));
                            createdPuzzles.remove(puzzleToInt(puzzle));
                            depthCounter++;
                        }   
                    }
                }
            }
            createdPuzzles.clear();
            depthCounter = 0;
            while(depthCounter < iterations) {
                puzzle = ( i > 20 ? generateRandomPuzzle() : scramblePuzzle(i));
                if(!createdPuzzles.containsKey(puzzleToInt(puzzle))) {
                    createdPuzzles.put(puzzleToInt(puzzle), puzzle);
                    if(solvable(puzzle)) {
                        long start = System.currentTimeMillis();
                        Node testCase = aStarSearch(puzzle, false);
                        long end = System.currentTimeMillis();
                        if(testCase != null && testCase.getDepth() == i) {
                            testCases.add(new TestCase(testCase, numberOfNodes, 
                                                       testCase.getDepth(), 
                                                       false, end-start));
                            createdPuzzles.remove(puzzleToInt(puzzle));
                            depthCounter++;
                        }   
                    }
                }
            }            
        }
        
        System.out.println("Depth:\tAvg. number of nodes (H1)\tAvg. number of "+
                           "nodes (H2)\tAvg. time (H1) (ms)\tAvg. time (H2) (ms)");
        for(int j = depthLow; j <= depthHigh; j++) {
            if(testCases.isEmpty() || testCases.peek().getDepth() == j) {
                System.out.print(j + "\t");
                long numberOfNodesH1Sum = 0, numberOfNodesH2Sum = 0;
                long totalTimeH1 = 0, totalTimeH2 = 0;
                int numberOfH1 = 0, numberOfH2 = 0;
                while(!testCases.isEmpty() && testCases.peek().getDepth()==j) {
                    TestCase current = testCases.remove();
                    if(current.getH1()) {
                        numberOfH1++;
                        numberOfNodesH1Sum += current.getNumberOfNodes();
                        totalTimeH1 += current.getTime();
                    }
                    else {
                        numberOfH2++;
                        numberOfNodesH2Sum += current.getNumberOfNodes();
                        totalTimeH2 += current.getTime();
                    }
                }
                System.out.println((numberOfH1 == 0 ? "---" : 
                                    (numberOfNodesH1Sum / numberOfH1)) + 
                                   "\t\t\t\t" + 
                                   (numberOfH2 == 0 ? "---" : 
                                    (numberOfNodesH2Sum / numberOfH2)) + 
                                   "\t\t\t\t" +
                                   ((numberOfH1) == 0 ? "---" : 
                                    ((float)totalTimeH1 / (float)(numberOfH1)))+
                                   "\t\t\t" + 
                                   ((numberOfH2) == 0 ? "---" : 
                                    ((float)totalTimeH2 / (float)(numberOfH2))));
            }
            else {
                System.out.println("---\t----\t\t---\t\t---\t\t---");
            }
        }       
    }
    
    /**
     * This method is the first method that generates a jumbled puzzle. In a
     * loop between 0 and (SIZE*SIZE), the method places that number in a random
     * position of the puzzle. The puzzle is then returned.
     * @return A jumbled puzzle (double char array).
     */
    public static char[][] generateRandomPuzzle() {
        Random rdm = new Random();
        char[][] result = new char[SIZE][SIZE];
        for(int i = 0; i < SIZE*SIZE; i++) {
            int row = rdm.nextInt(SIZE);
            int column = rdm.nextInt(SIZE);
            while(result[row][column] != '\u0000') {
                row = rdm.nextInt(SIZE);
                column = rdm.nextInt(SIZE);
            }
            result[row][column] = Character.forDigit(i, 10);
        }
        return result;
    }
    
    /**
     * This method is the second method that generates a jumbled puzzle. Instead
     * of producing a puzzle with completely random numbers from 0 - SIZE*SIZE,
     * it performs "numberOfPuzzleShifts" blank tile shifts. The result is a
     * puzzle that is jumbled, but not as random as generateRandomPuzzle()
     * produces, which produces easier to solve puzzles within a certain depth
     * number in a small number of moves (in the case of this program, less than
     * 20 moves).
     * @param numberOfPuzzleShifts Number of blank tile shifts to be made.
     * @return A jumbled puzzle (double char array).
     */
    public static char[][] scramblePuzzle(int numberOfPuzzleShifts) {
        Random rdm = new Random();
        char[][] result = copy(goal);
        Action[] actions = {Action.LEFT, Action.RIGHT, Action.UP, Action.DOWN};
        while(numberOfPuzzleShifts > 0) {
            char[][] newInitial;
            int randomAction = rdm.nextInt(actions.length);
            newInitial = performAction(result, actions[randomAction]);
            if(!equals(result, newInitial)) {
                result = copy(newInitial);
                numberOfPuzzleShifts--;
            }          
        }
        return result;
    }
    
    /**
     * This method determines if a given puzzle is solvable, which is determined
     * by counting the number of inversions in the given puzzle. If the total
     * number of inversions is even, then it is solvable, otherwise, it is
     * false.
     * @param a Given puzzle (double char array).
     * @return True is solvable, false if unsolvable.
     */
    public static boolean solvable(char[][] a) {
        int inversions = 0;
        for(int i = 0; i < SIZE*SIZE; i++) {
            int compare = Character.getNumericValue(a[i/SIZE][i%SIZE]);
            if(compare != 0) {
                for(int j = i; j < SIZE*SIZE; j++) {                 
                    if((compare>Character.getNumericValue(a[j/SIZE][j%SIZE])) && 
                       (Character.getNumericValue(a[j/SIZE][j%SIZE]) != 0))
                        inversions++;                   
                }
            }
        }
        return inversions % 2 == 0;
    }
    
    /**
     * This method performs A* Search on a given puzzle (double char array) and
     * calculates it using the h1 heuristic equation (if boolean h1 is true) or
     * the h2 equation (if boolean h1 is false). The method returns the optimal
     * node which represents the goal state, having parent nodes that create a
     * path of moves that led the initial state to that goal state. The number
     * of nodes can also determine how many moves it took to solve the puzzle.
     * @param initialState The initial state to be solved.
     * @param h1 Boolean which determines which heuristic equation will be used
     *           to calculate the estimated cost from the generated state to
     *           the goal state.
     * @return The goal state which has parent nodes leading back to the initial
     *         state.
     */
    public static Node aStarSearch(char[][] initialState, boolean h1) {
        //Adds initial state to the state tree.
        frontier.clear();
        explored.clear();
        maxDepth = 0;
        Node current = new Node(initialState, heuristic(initialState, h1));
        frontier.add(current);
        numberOfNodes = 1;
        
        while(!equals(current.state, goal)) {           
            explored.put(puzzleToInt(current.state), current.state);
            updateFrontier(current, h1);
            frontier.remove(current);
            current = frontier.peek();
        }
        
        return current;
    }
    
    /**
     * This method updates the frontier while performing the A* Search, which
     * checks if actions LEFT, RIGHT, UP, or DOWN can be performed on the given
     * state n.
     * @param n Given node, or state.
     * @param h1 Boolean which determines which heuristic equation will be used
     *           to calculate the estimated cost from the generated state to
     *           the goal state.
     */
    public static void updateFrontier(Node n, boolean h1) {
        addActionToFrontier(n, Action.LEFT, h1);
        addActionToFrontier(n, Action.RIGHT, h1);
        addActionToFrontier(n, Action.UP, h1);
        addActionToFrontier(n, Action.DOWN, h1);
    }
    
    /**
     * This method adds a child state (determined by Action a) of parent state n
     * to the frontier. If the action is permissible, the child state is added
     * to the frontier, and the state is also added with the cost so far and
     * the heuristic cost (result of h1 or h2 determined by boolean h1).
     * @param n Given node, or state.
     * @param a Given action to be acted on state n.
     * @param h1 Boolean which determines which heuristic equation will be used
     *           to calculate the estimated cost from the generated state to
     *           the goal state.
     */
    public static void addActionToFrontier(Node n, Action a, boolean h1) {
        char[][] state;
        state = performAction(n.state, a);
        if(!equals(state, n.state) && 
           !explored.containsKey(puzzleToInt(state))) {
            frontier.add(new Node(state, n, a, n.getCostSoFar() + STEP_COST, 
                                  heuristic(state, h1), n.getDepth()+1));
            if(maxDepth < n.getDepth()+1)
                maxDepth = n.getDepth()+1;
            numberOfNodes++;
        }
    }
    
    /**
     * This method returns either the first or second heuristic result of a
     * given puzzle, depending on the boolean h1.
     * @param a Given puzzle (double char array).
     * @param h1 If true, the method returns the result of the first heuristic
     *           function. If false, the method returns the result of the
     *           second heuristic function.
     * @return The result of either h1 or h2.
     */
    public static int heuristic(char[][] a, boolean h1) {
        if(h1)
            return h1(a);
        return h2(a);
    }
    
    /**
     * This method represents the first heuristic for the 8-puzzle solver. This
     * heuristic returns the sum of all the misplaced tiles from their
     * respective positions in the goal state.
     * @param a Given puzzle (double char array).
     * @return The result of this heuristic.
     */
    public static int h1(char[][] a) {
        int result = 0;
        for(int i = 0; i < SIZE; i++) {
            for(int j = 0; j < SIZE; j++) {                
                if( (a[i][j] != '0') && (a[i][j] != goal[i][j]) )
                    result += STEP_COST;
            }
        }
        return result;
    }
    
    /**
     * This method represents the second heuristic for the 8-puzzle solver. This
     * heuristic returns the sum of all the Manhattan distances of all the tiles
     * from their respective numbers in the goal state.
     * @param a Given puzzle (double char array).
     * @return The result of this heuristic.
     */
    public static int h2(char[][] a) {
        int result = 0;
        for(int i = 0; i < SIZE*SIZE; i++) {
            int compare = Character.getNumericValue(a[i/SIZE][i%SIZE]);
            if(compare != 0) {
                for(int j = 0; j < SIZE*SIZE; j++) {                 
                    if(compare==Character.getNumericValue(goal[j/SIZE][j%SIZE]))
                        result+=findDifference(i/SIZE, j/SIZE, i%SIZE, j%SIZE);
                }
            }
        }
        return result;
    }
    
    /**
     * This method finds the Manhattan difference between two given positions
     * of a puzzle.
     * @param row1 Row of the first position.
     * @param row2 Row of the second position.
     * @param column1 Column of the first position.
     * @param column2 Column of the second position.
     * @return The Manhattan difference between the two positions.
     */
    public static int findDifference(int row1, int row2, int column1, 
                                     int column2) {
        return Math.abs(row1-row2) + Math.abs(column1-column2);
    }
    
    /**
     * This method, given an action LEFT, RIGHT, UP, or DOWN, swaps the blank
     * tile of the given puzzle with the number on its left, right, up, or down,
     * respectively. If the action cannot be performed, the same puzzle that
     * is inputted is returned with no changes made.
     * @param currentState Given puzzle.
     * @param a Given action.
     * @return A copy of the inputted puzzle with the swap made (or the
     *         identical puzzle inputted if the swap couldn't be made).
     */
    public static char[][] performAction(char[][] currentState, Action a) {
        int blankRow = 0, blankColumn = 0;
        char[][] result = new char[SIZE][SIZE];
        for(int i = 0; i < SIZE; i++) {
            for(int j = 0; j < SIZE; j++) {
                if(currentState[i][j] == '0') {
                    blankRow = i;
                    blankColumn = j;
                }
                result[i][j] = currentState[i][j];
            }
        }
        
        if((a == Action.LEFT && blankColumn == 0) ||
           (a == Action.RIGHT && blankColumn == SIZE-1) ||
           (a == Action.UP && blankRow == 0) ||
           (a == Action.DOWN && blankRow == SIZE-1))
            return result;
        
        switch (a) {
            case LEFT:
                swap(result, blankRow, blankRow, blankColumn, blankColumn-1);
                break;
            case RIGHT:
                swap(result, blankRow, blankRow, blankColumn, blankColumn+1);
                break;
            case UP:
                swap(result, blankRow, blankRow-1, blankColumn, blankColumn);
                break;
            case DOWN:
                swap(result, blankRow, blankRow+1, blankColumn, blankColumn);
                break;
        }
        return result;
    }
    
    /**
     * Swaps two chars of given positions in a given puzzle (double char array).
     * @param a The given puzzle.
     * @param row1 row of the first char.
     * @param row2 row of the second char.
     * @param column1 column of the first char.
     * @param column2 column of the second char.
     */
    public static void swap(char[][] a, int row1, int row2, 
                            int column1, int column2) {
        char temp = a[row1][column1];
        a[row1][column1] = a[row2][column2];
        a[row2][column2] = temp;
    }
    
    /**
     * This method returns true if both puzzles (a and b) are equivalent. It
     * returns false otherwise.
     * @param a puzzle a (double char array).
     * @param b puzzle b (double char array).
     * @return Returns true if a and b are equivalent, false otherwise.
     */
    public static boolean equals(char[][] a, char[][] b) {
        for(int i = 0; i < SIZE; i++) {
            for(int j = 0; j < SIZE; j++) {
                if(a[i][j] != b[i][j])
                    return false;
            }
        }
        return true;
    }
    
    /**
     * This method prints a given char array, used to display puzzles. It can
     * display them in multiple rows (if grid is true), or in one line with no
     * spaces between the numbers (if grid is false).
     * @param a The given puzzle (double char array)
     * @param grid If true, the puzzle is printed in multiple rows. If false,
     *             the puzzle is printed in one line.
     */
    public static void printArray(char[][] a, boolean grid) {
        for(int i = 0; i < SIZE; i++) {
            for(int j = 0; j < SIZE; j++)
                System.out.print(a[i][j] + (grid ? "\t" : ""));
            System.out.print((grid ? "\n" : ""));
        }
    }
    
    /**
     * This method turns a string of SIZE*SIZE numbers into a puzzle.
     * @param a string of SIZE*SIZE numbers.
     * @return a puzzle (double char array) that represents the inputted string.
     */
    public static char[][] stringToPuzzle(String a) {
        if(a.length() != SIZE*SIZE)
            return null;
        char[][] result = new char[SIZE][SIZE];
        for(int i = 0; i < SIZE*SIZE; i++)
            result[i/SIZE][i%SIZE] = a.charAt(i);
        return result;   
    }
    
    /**
     * This method copies an inputted puzzle and returns the copy.
     * @param a puzzle (double char array).
     * @return a copy of the inputted array.
     */
    public static char[][] copy(char[][] a) {
        char[][] result = new char[SIZE][SIZE];
        for(int i = 0; i < SIZE; i++) {
            for(int j = 0; j < SIZE; j++)
               result[i][j] = a[i][j];
        }
        return result;
    }
    
    /**
     * This method converts a puzzle into an integer by grouping all SIZE*SIZE
     * numbers and forming one SIZE*SIZE digit number. This is used as a key
     * generator when inputting puzzle states into the explored set.
     * @param a puzzle (double char array).
     * @return an integer representation of the puzzle.
     */
    public static int puzzleToInt(char[][] a) {
        String result = "";
        for(int i = 0; i < SIZE*SIZE; i++) {
            result = result + a[i/SIZE][i%SIZE];
        }
        return Integer.parseInt(result);
    }
    
    /**
     * This method checks if a given string is a valid input for inputting a
     * puzzle from the user. It checks if the string is of length SIZE*SIZE,
     * and then checks if every character is a number. If it is invalid, false
     * is returned, otherwise, the method returns true.
     * @param a inputted string
     * @return true if input is valid, false otherwise.
     */
    public static boolean validPuzzleString(String a) {
        if(a.length() != SIZE*SIZE)
            return false;
        for(int i = 0; i < SIZE*SIZE; i++) {
            if(a.charAt(i) < 48 || a.charAt(i) > 57)
                return false;
        }
        return true;
    }
}
